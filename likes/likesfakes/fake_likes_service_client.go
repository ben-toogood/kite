// Code generated by counterfeiter. DO NOT EDIT.
package likesfakes

import (
	"context"
	"sync"

	"github.com/ben-toogood/kite/likes"
	"google.golang.org/grpc"
)

type FakeLikesServiceClient struct {
	CountStub        func(context.Context, *likes.CountRequest, ...grpc.CallOption) (*likes.CountResponse, error)
	countMutex       sync.RWMutex
	countArgsForCall []struct {
		arg1 context.Context
		arg2 *likes.CountRequest
		arg3 []grpc.CallOption
	}
	countReturns struct {
		result1 *likes.CountResponse
		result2 error
	}
	countReturnsOnCall map[int]struct {
		result1 *likes.CountResponse
		result2 error
	}
	GetStub        func(context.Context, *likes.GetRequest, ...grpc.CallOption) (*likes.GetResponse, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 context.Context
		arg2 *likes.GetRequest
		arg3 []grpc.CallOption
	}
	getReturns struct {
		result1 *likes.GetResponse
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *likes.GetResponse
		result2 error
	}
	LikeStub        func(context.Context, *likes.LikeRequest, ...grpc.CallOption) (*likes.LikeResponse, error)
	likeMutex       sync.RWMutex
	likeArgsForCall []struct {
		arg1 context.Context
		arg2 *likes.LikeRequest
		arg3 []grpc.CallOption
	}
	likeReturns struct {
		result1 *likes.LikeResponse
		result2 error
	}
	likeReturnsOnCall map[int]struct {
		result1 *likes.LikeResponse
		result2 error
	}
	UnlikeStub        func(context.Context, *likes.UnlikeRequest, ...grpc.CallOption) (*likes.UnlikeResponse, error)
	unlikeMutex       sync.RWMutex
	unlikeArgsForCall []struct {
		arg1 context.Context
		arg2 *likes.UnlikeRequest
		arg3 []grpc.CallOption
	}
	unlikeReturns struct {
		result1 *likes.UnlikeResponse
		result2 error
	}
	unlikeReturnsOnCall map[int]struct {
		result1 *likes.UnlikeResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLikesServiceClient) Count(arg1 context.Context, arg2 *likes.CountRequest, arg3 ...grpc.CallOption) (*likes.CountResponse, error) {
	fake.countMutex.Lock()
	ret, specificReturn := fake.countReturnsOnCall[len(fake.countArgsForCall)]
	fake.countArgsForCall = append(fake.countArgsForCall, struct {
		arg1 context.Context
		arg2 *likes.CountRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.CountStub
	fakeReturns := fake.countReturns
	fake.recordInvocation("Count", []interface{}{arg1, arg2, arg3})
	fake.countMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLikesServiceClient) CountCallCount() int {
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	return len(fake.countArgsForCall)
}

func (fake *FakeLikesServiceClient) CountCalls(stub func(context.Context, *likes.CountRequest, ...grpc.CallOption) (*likes.CountResponse, error)) {
	fake.countMutex.Lock()
	defer fake.countMutex.Unlock()
	fake.CountStub = stub
}

func (fake *FakeLikesServiceClient) CountArgsForCall(i int) (context.Context, *likes.CountRequest, []grpc.CallOption) {
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	argsForCall := fake.countArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLikesServiceClient) CountReturns(result1 *likes.CountResponse, result2 error) {
	fake.countMutex.Lock()
	defer fake.countMutex.Unlock()
	fake.CountStub = nil
	fake.countReturns = struct {
		result1 *likes.CountResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeLikesServiceClient) CountReturnsOnCall(i int, result1 *likes.CountResponse, result2 error) {
	fake.countMutex.Lock()
	defer fake.countMutex.Unlock()
	fake.CountStub = nil
	if fake.countReturnsOnCall == nil {
		fake.countReturnsOnCall = make(map[int]struct {
			result1 *likes.CountResponse
			result2 error
		})
	}
	fake.countReturnsOnCall[i] = struct {
		result1 *likes.CountResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeLikesServiceClient) Get(arg1 context.Context, arg2 *likes.GetRequest, arg3 ...grpc.CallOption) (*likes.GetResponse, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 context.Context
		arg2 *likes.GetRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1, arg2, arg3})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLikesServiceClient) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeLikesServiceClient) GetCalls(stub func(context.Context, *likes.GetRequest, ...grpc.CallOption) (*likes.GetResponse, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeLikesServiceClient) GetArgsForCall(i int) (context.Context, *likes.GetRequest, []grpc.CallOption) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLikesServiceClient) GetReturns(result1 *likes.GetResponse, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *likes.GetResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeLikesServiceClient) GetReturnsOnCall(i int, result1 *likes.GetResponse, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *likes.GetResponse
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *likes.GetResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeLikesServiceClient) Like(arg1 context.Context, arg2 *likes.LikeRequest, arg3 ...grpc.CallOption) (*likes.LikeResponse, error) {
	fake.likeMutex.Lock()
	ret, specificReturn := fake.likeReturnsOnCall[len(fake.likeArgsForCall)]
	fake.likeArgsForCall = append(fake.likeArgsForCall, struct {
		arg1 context.Context
		arg2 *likes.LikeRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.LikeStub
	fakeReturns := fake.likeReturns
	fake.recordInvocation("Like", []interface{}{arg1, arg2, arg3})
	fake.likeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLikesServiceClient) LikeCallCount() int {
	fake.likeMutex.RLock()
	defer fake.likeMutex.RUnlock()
	return len(fake.likeArgsForCall)
}

func (fake *FakeLikesServiceClient) LikeCalls(stub func(context.Context, *likes.LikeRequest, ...grpc.CallOption) (*likes.LikeResponse, error)) {
	fake.likeMutex.Lock()
	defer fake.likeMutex.Unlock()
	fake.LikeStub = stub
}

func (fake *FakeLikesServiceClient) LikeArgsForCall(i int) (context.Context, *likes.LikeRequest, []grpc.CallOption) {
	fake.likeMutex.RLock()
	defer fake.likeMutex.RUnlock()
	argsForCall := fake.likeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLikesServiceClient) LikeReturns(result1 *likes.LikeResponse, result2 error) {
	fake.likeMutex.Lock()
	defer fake.likeMutex.Unlock()
	fake.LikeStub = nil
	fake.likeReturns = struct {
		result1 *likes.LikeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeLikesServiceClient) LikeReturnsOnCall(i int, result1 *likes.LikeResponse, result2 error) {
	fake.likeMutex.Lock()
	defer fake.likeMutex.Unlock()
	fake.LikeStub = nil
	if fake.likeReturnsOnCall == nil {
		fake.likeReturnsOnCall = make(map[int]struct {
			result1 *likes.LikeResponse
			result2 error
		})
	}
	fake.likeReturnsOnCall[i] = struct {
		result1 *likes.LikeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeLikesServiceClient) Unlike(arg1 context.Context, arg2 *likes.UnlikeRequest, arg3 ...grpc.CallOption) (*likes.UnlikeResponse, error) {
	fake.unlikeMutex.Lock()
	ret, specificReturn := fake.unlikeReturnsOnCall[len(fake.unlikeArgsForCall)]
	fake.unlikeArgsForCall = append(fake.unlikeArgsForCall, struct {
		arg1 context.Context
		arg2 *likes.UnlikeRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.UnlikeStub
	fakeReturns := fake.unlikeReturns
	fake.recordInvocation("Unlike", []interface{}{arg1, arg2, arg3})
	fake.unlikeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLikesServiceClient) UnlikeCallCount() int {
	fake.unlikeMutex.RLock()
	defer fake.unlikeMutex.RUnlock()
	return len(fake.unlikeArgsForCall)
}

func (fake *FakeLikesServiceClient) UnlikeCalls(stub func(context.Context, *likes.UnlikeRequest, ...grpc.CallOption) (*likes.UnlikeResponse, error)) {
	fake.unlikeMutex.Lock()
	defer fake.unlikeMutex.Unlock()
	fake.UnlikeStub = stub
}

func (fake *FakeLikesServiceClient) UnlikeArgsForCall(i int) (context.Context, *likes.UnlikeRequest, []grpc.CallOption) {
	fake.unlikeMutex.RLock()
	defer fake.unlikeMutex.RUnlock()
	argsForCall := fake.unlikeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLikesServiceClient) UnlikeReturns(result1 *likes.UnlikeResponse, result2 error) {
	fake.unlikeMutex.Lock()
	defer fake.unlikeMutex.Unlock()
	fake.UnlikeStub = nil
	fake.unlikeReturns = struct {
		result1 *likes.UnlikeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeLikesServiceClient) UnlikeReturnsOnCall(i int, result1 *likes.UnlikeResponse, result2 error) {
	fake.unlikeMutex.Lock()
	defer fake.unlikeMutex.Unlock()
	fake.UnlikeStub = nil
	if fake.unlikeReturnsOnCall == nil {
		fake.unlikeReturnsOnCall = make(map[int]struct {
			result1 *likes.UnlikeResponse
			result2 error
		})
	}
	fake.unlikeReturnsOnCall[i] = struct {
		result1 *likes.UnlikeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeLikesServiceClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.countMutex.RLock()
	defer fake.countMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.likeMutex.RLock()
	defer fake.likeMutex.RUnlock()
	fake.unlikeMutex.RLock()
	defer fake.unlikeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLikesServiceClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ likes.LikesServiceClient = new(FakeLikesServiceClient)
